// Generated by Babel
// Generated by Babel
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global window */


var _fingerprint = require("./fingerprint");

var _fingerprint2 = _interopRequireDefault(_fingerprint);

var _error = require("./error");

var _error2 = _interopRequireDefault(_error);

var _extend = require("extend");

var _extend2 = _interopRequireDefault(_extend);

var _source = require("./source");

var _base = require("./base64");

var Base64 = _interopRequireWildcard(_base);

var _storage = require("./storage");

var Storage = _interopRequireWildcard(_storage);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultOptions = {
  wsendpoint: "",
  fingerprint: _fingerprint2.default,
  resume: true,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  headers: {},
  chunkSize: Infinity,
  withCredentials: false,
  uploadUrl: null,
  uploadSize: null
};

var Upload = function () {
  function Upload(file, options) {
    _classCallCheck(this, Upload);

    this.options = (0, _extend2.default)(true, {}, defaultOptions, options);

    // The underlying File/Blob object
    this.file = file;

    // The underlying WebSocket connection which will be use for upload file
    this._ws = null;

    // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.
    this._source = null;

    // The file's size in bytes
    this._size = null;

    // True if the current PATCH request has been aborted
    this._aborted = false;

    // The URL against which the file will be uploaded
    this.url = null;

    // The fingerpinrt for the current file (set after start())
    this._fingerprint = null;

    // The offset used in the current PATCH request
    this._offset = null;
  }

  _createClass(Upload, [{
    key: "startWSTest",
    value: function startWSTest() {
      this._createUpload();
    }
  }, {
    key: "start",
    value: function start() {

      if (!window.WebSocket) {
        this._emitError(new Error("tus: your browser doesn't supports WebSocket"));
        return;
      }

      if (!this.options.wsendpoint) {
        this._emitError(new Error("tus: no wsendpoint provided"));
        return;
      }

      var file = this.file;

      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));
        return;
      }

      var source = this._source = (0, _source.getSource)(file, this.options.chunkSize);

      // Firstly, check if the caller has supplied a manual upload size or else
      // we will use the calculated size by the source object.
      if (this.options.uploadSize != null) {
        var size = +this.options.uploadSize;
        if (isNaN(size)) {
          throw new Error("tus: cannot convert `uploadSize` option into a number");
        }

        this._size = size;
      } else {
        var _size = source.size;

        // The size property will be null if we cannot calculate the file's size,
        // for example if you handle a stream.
        if (_size == null) {
          throw new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option");
        }

        this._size = _size;
      }

      // Reset the aborted flag when the upload is started or else the
      // _startUpload will stop before sending a request if the upload has been
      // aborted previously.
      this._aborted = false;

      // The upload had been started previously and we should reuse this URL.
      if (this.url != null) {
        this._resumeUpload();
        return;
      }

      // A URL has manually been specified, so we try to resume
      if (this.options.uploadUrl != null) {
        this.url = this.options.uploadUrl;
        this._resumeUpload();
        return;
      }

      // Try to find the endpoint for the file in the storage
      if (this.options.resume) {
        this._fingerprint = this.options.fingerprint(file);
        var resumedUrl = Storage.getItem(this._fingerprint);

        if (resumedUrl != null) {
          this.url = resumedUrl;
          this._resumeUpload();
          return;
        }
      }

      // An upload has not started for the file yet, so we start a new one
      this._createUpload();
    }
  }, {
    key: "_setRequestHeaders",
    value: function _setRequestHeaders() {
      var headers = {
        "Tus-Resumable": "1.0.0"
      };

      var optionsHeaders = this.options.headers;

      for (var name in optionsHeaders) {
        headers[name] = optionsHeaders[name];
      }

      return headers;
    }

    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this = this;

      var ws = this._newWebSocket();

      ws.onopen = function (event) {
        console.log("[Create] WS opened: ", event);

        var headers = _this._setRequestHeaders();
        headers["Upload-Length"] = _this._size;

        var metadata = encodeMetadata(_this.options.metadata);
        if (metadata !== "") {
          headers["Upload-Metadata"] = metadata;
        }

        ws.send(JSON.stringify({
          method: "POST",
          headers: headers,
          body: null
        }));
      };

      ws.onerror = function (event) {
        console.log("[Create] WS error: ", event);
        throw new Error("tus: failed to create upload");
      };

      ws.onclose = function (event) {
        console.log("[Create] WS closed: ", event);
        throw new Error("tus: failed to create upload");
      };

      ws.onmessage = function (message) {
        var response = JSON.parse(message.data);

        // Start upload
        console.log("[Create] WS message: ", message);
        console.log("[Create] WS data: ", response);

        if (!inStatusCategory(response.status, 200)) {
          // Must _emitXhrError
          _this._emitError(new Error("tus: unexpected response while creating upload"));
          return;
        }

        // this.url = resolveUrl(this.options.wsendpoint, response.headers["Location"]);
        _this.url = response.headers["Location"];

        if (_this.options.resume) {
          Storage.setItem(_this._fingerprint, _this.url);
        }

        _this._offset = 0;
        _this._startUpload();
      };
    }
  }, {
    key: "_newWebSocket",
    value: function _newWebSocket() {
      return new WebSocket("ws://" + this.options.wsendpoint + "/ws");
    }
  }, {
    key: "abort",
    value: function abort() {
      if (this._xhr !== null) {
        this._xhr.abort();
        this._source.close();
        this._aborted = true;
      }

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }
    }
  }, {
    key: "_emitXhrError",
    value: function _emitXhrError(xhr, err, causingErr) {
      this._emitError(new _error2.default(err, causingErr, xhr));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }

    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     * @param  {number} bytesSent  Number of bytes sent to the server.
     * @param  {number} bytesTotal Total number of bytes to be sent to the server.
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }

    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param  {number} chunkSize  Size of the chunk that was accepted by the
     *                             server.
     * @param  {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param  {number} bytesTotal Total number of bytes to be sent to the server.
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }

    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this2 = this;

      var ws = this._newWebSocket();

      ws.onopen = function (event) {
        console.log("[Resume] WS opened: ", event);

        ws.send({
          method: "HEAD",
          headers: _this2._setRequestHeaders(),
          body: null
        });
      };

      ws.onerror = function (event) {
        console.log("[Resume] WS error: ", event);
        // Must _emitXhrError
        _this2._emitError(new Error("tus: failed to resume upload"));
      };

      ws.onclose = function (event) {
        console.log("[Resume] WS closed: ", event);
        // Must _emitXhrError
        _this2._emitError(new Error("tus: failed to resume upload"));
      };

      ws.onmessage = function (message) {
        var response = JSON.parse(message.data);
        var headers = response.headers;

        // Resume upload
        console.log("[Resume] WS message: ", message);
        console.log("[Resume] WS data: ", response);

        if (!inStatusCategory(response.status, 200)) {
          if (_this2.options.resume && inStatusCategory(response.status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            Storage.removeItem(_this2._fingerprint);
          }

          // !!!!!!!! ПРОТЕСТИТЬ !!!!!!!!
          // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.
          if (response.status === 423) {
            // Must _emitXhrError
            _this2._emitError(new Error("tus: upload is currently locked; retry later"));
            return;
          }

          // Try to create a new upload
          _this2.url = null;
          _this2._createUpload();
          return;
        }

        var offset = parseInt(headers["Upload-Offset"], 10);
        if (isNaN(offset)) {
          // MUST _emitXhrError
          _this2._emitError(new Error("tus: invalid or missing offset value"));
          return;
        }

        var length = parseInt(headers["Upload-Length"], 10);
        if (isNaN(length)) {
          // MUST _emitXhrError
          _this2._emitError(new Error("tus: invalid or missing length value"));
          return;
        }

        // Upload has already been completed and we do not need to send additional
        // data to the server
        if (offset === length) {
          _this2._emitProgress(length, length);
          _this2._emitSuccess();
          return;
        }

        _this2._offset = offset;
        _this2._startUpload();
      };
    }

    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_startUpload",
    value: function _startUpload() {
      var _this3 = this;

      // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.
      if (this._aborted) {
        return;
      }

      var ws = this._newWebSocket();

      ws.onopen = function (event) {
        console.log("[Start] WS opened: ", event);

        // Test support for progress events before attaching an event listener
        // if ("upload" in xhr) {
        //   xhr.upload.onprogress = (e) => {
        //     if (!e.lengthComputable) {
        //       return;
        //     }

        //     this._emitProgress(start + e.loaded, this._size);
        //   };
        // }

        var headers = _this3._setRequestHeaders();
        headers["Upload-Offset"] = _this3._offset;
        headers["Content-Type"] = "application/offset+octet-stream";

        var start = _this3._offset;
        var end = _this3._offset + _this3.options.chunkSize;

        // The specified chunkSize may be Infinity or the calcluated end position
        // may exceed the file's size. In both cases, we limit the end position to
        // the input's total size for simpler calculations and correctness.
        if (end === Infinity || end > _this3._size) {
          end = _this3._size;
        }

        ws.send({
          method: "PATCH",
          headers: headers,
          body: _this3._source.slice(start, end)
        });
      };

      ws.onerror = function (event) {
        console.log("[Start] WS error: ", event);

        if (_this3._aborted) {
          return;
        }

        // Must _emitXhrError
        _this3._emitError(new Error("tus: failed to upload chunk at offset " + _this3._offset));
      };

      ws.onclose = function (event) {
        console.log("[Start] WS close: ", event);

        if (_this3._aborted) {
          return;
        }

        // Must _emitXhrError
        _this3._emitError(new Error("tus: failed to upload chunk at offset " + _this3._offset));
      };

      ws.onmessage = function (message) {
        var response = JSON.parse(message.data);
        var headers = response.headers;

        // Resume upload
        console.log("[Start] WS message: ", message);
        console.log("[Start] WS data: ", response);

        if (!inStatusCategory(response.status, 200)) {
          // Must _emitXhrError
          _this3._emitError(new Error("tus: unexpected response while uploading chunk"));
          return;
        }

        var offset = parseInt(headers["Upload-Offset"], 10);
        if (isNaN(offset)) {
          // Must _emitXhrError
          _this3._emitError(new Error("tus: invalid or missing offset value"));
          return;
        }

        _this3._emitProgress(offset, _this3._size);
        _this3._emitChunkComplete(offset - _this3._offset, offset, _this3._size);

        _this3._offset = offset;

        if (offset == _this3._size) {
          // Yay, finally done :)
          _this3._emitSuccess();
          _this3._source.close();
          return;
        }

        _this3._startUpload();
      };
    }
  }]);

  return Upload;
}();

function encodeMetadata(metadata) {
  if (!Base64.isSupported) {
    return "";
  }

  var encoded = [];

  for (var key in metadata) {
    encoded.push(key + " " + Base64.encode(metadata[key]));
  }

  return encoded.join(",");
}

/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */
function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}

Upload.defaultOptions = defaultOptions;

exports.default = Upload;