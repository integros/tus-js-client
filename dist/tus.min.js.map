{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/base64.js","lib/error.js","lib/fingerprint.js","lib/index.js","lib/source.js","lib/storage.js","lib/upload.js","node_modules/extend/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","tus","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","encode","btoa","data","unescape","encodeURIComponent","isSupported","DetailedError","error","causingErr","arguments","undefined","xhr","_classCallCheck","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","message","originalRequest","causingError","toString","status","responseText","fingerprint","file","name","type","size","lastModified","join","_upload","_storage","defaultOptions","_window","XMLHttpRequest","Blob","prototype","slice","Upload","_upload2","default","canStoreURLs","getSource","FileSource","_file","start","end","input","setItem","getItem","removeItem","hasStorage","key","localStorage","SECURITY_ERR","QUOTA_EXCEEDED_ERR","value","_fingerprint","_error","_extend","_source","_base","Base64","Storage","wsendpoint","_fingerprint2","resume","onProgress","onChunkComplete","onSuccess","onError","headers","chunkSize","Infinity","withCredentials","uploadUrl","uploadSize","options","_extend2","_ws","_size","_aborted","url","_offset","_createUpload","WebSocket","_emitError","source","isNaN","_resumeUpload","resumedUrl","Tus-Resumable","optionsHeaders","ws","_newWebSocket","onopen","event","console","log","_setRequestHeaders","metadata","encodeMetadata","send","JSON","stringify","method","body","onerror","onclose","onmessage","response","parse","inStatusCategory","_startUpload","_xhr","abort","close","_retryTimeout","clearTimeout","err","_error2","bytesSent","bytesTotal","bytesAccepted","_this2","offset","parseInt","_emitProgress","_emitSuccess","_this3","_emitChunkComplete","encoded","push","category","hasOwn","hasOwnProperty","toStr","isArray","arr","Array","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","extend","src","copy","copyIsArray","clone","target","deep"],"mappings":"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","file":"./dist/tus.min.js","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global: window */\n\nconst {btoa} = window;\n\nexport function encode(data) {\n  return btoa(unescape(encodeURIComponent(data)));\n}\n\nexport const isSupported = \"btoa\" in window;\n","class DetailedError extends Error {\n  constructor(error, causingErr = null, xhr = null) {\n    super(error.message);\n\n    this.originalRequest = xhr;\n    this.causingError = causingErr;\n\n    let message = error.message;\n    if (causingErr != null) {\n      message += `, caused by ${causingErr.toString()}`;\n    }\n    if (xhr != null) {\n      message += `, originated from request (response code: ${xhr.status}, response text: ${xhr.responseText})`;\n    }\n    this.message = message;\n  }\n}\n\nexport default DetailedError;\n","/**\n * Generate a fingerprint for a file which will be used the store the endpoint\n *\n * @param {File} file\n * @return {String}\n */\nexport default function fingerprint(file) {\n  return [\n\t\t\"tus\",\n\t\tfile.name,\n\t\tfile.type,\n\t\tfile.size,\n\t\tfile.lastModified\n  ].join(\"-\");\n}\n","/* global window */\nimport Upload from \"./upload\";\nimport {canStoreURLs} from \"./storage\";\n\nconst {defaultOptions} = Upload;\n\nif (typeof window !== \"undefined\") {\n  // Browser environment using XMLHttpRequest\n  const {XMLHttpRequest, Blob} = window;\n\n  var isSupported = (\n    XMLHttpRequest &&\n    Blob &&\n    typeof Blob.prototype.slice === \"function\"\n  );\n} else {\n  // Node.js environment using http module\n  var isSupported = true;\n}\n\n// The usage of the commonjs exporting syntax instead of the new ECMAScript\n// one is actually inteded and prevents weird behaviour if we are trying to\n// import this module in another module using Babel.\nmodule.exports = {\n  Upload,\n  isSupported,\n  canStoreURLs,\n  defaultOptions\n};\n","class FileSource {\n  constructor(file) {\n    this._file = file;\n    this.size = file.size;\n  }\n\n  slice(start, end) {\n    return this._file.slice(start, end);\n  }\n\n  close() {}\n}\n\nexport function getSource(input) {\n  // Since we emulate the Blob type in our tests (not all target browsers\n  // support it), we cannot use `instanceof` for testing whether the input value\n  // can be handled. Instead, we simply check is the slice() function and the\n  // size property are available.\n  if (typeof input.slice === \"function\" && typeof input.size !== \"undefined\") {\n    return new FileSource(input);\n  }\n\n  throw new Error(\"source object may only be an instance of File or Blob in this environment\");\n}\n","/* global window, localStorage */\n\nlet hasStorage = false;\ntry {\n  hasStorage = \"localStorage\" in window;\n\n  // Attempt to store and read entries from the local storage to detect Private\n  // Mode on Safari on iOS (see #49)\n  var key = \"tusSupport\";\n  localStorage.setItem(key, localStorage.getItem(key));\n\n} catch (e) {\n  // If we try to access localStorage inside a sandboxed iframe, a SecurityError\n  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is\n  // thrown (see #49)\n  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {\n    hasStorage = false;\n  } else {\n    throw e;\n  }\n}\n\nexport const canStoreURLs = hasStorage;\n\nexport function setItem(key, value) {\n  if (!hasStorage) return;\n  return localStorage.setItem(key, value);\n}\n\nexport function getItem(key) {\n  if (!hasStorage) return;\n  return localStorage.getItem(key);\n}\n\nexport function removeItem(key) {\n  if (!hasStorage) return;\n  return localStorage.removeItem(key);\n}\n","/* global window */\nimport fingerprint from \"./fingerprint\";\nimport DetailedError from \"./error\";\nimport extend from \"extend\";\nimport {getSource} from \"./source\";\nimport * as Base64 from \"./base64\";\nimport * as Storage from \"./storage\";\n\nconst defaultOptions = {\n  wsendpoint: \"\",\n  fingerprint,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null\n};\n\nclass Upload {\n\n  constructor(file, options) {\n    this.options = extend(true, {}, defaultOptions, options);\n\n    // The underlying File/Blob object\n    this.file = file;\n\n    // The underlying WebSocket connection which will be use for upload file\n    this._ws = null;\n\n    // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n    this._source = null;\n\n    // The file's size in bytes\n    this._size = null;\n\n    // True if the current PATCH request has been aborted\n    this._aborted = false;\n\n    // The URL against which the file will be uploaded\n    this.url = null;\n\n    // The fingerpinrt for the current file (set after start())\n    this._fingerprint = null;\n\n    // The offset used in the current PATCH request\n    this._offset = null;\n  }\n\n  startWSTest() {\n    this._createUpload();\n  }\n\n  start() {\n\n    if (!window.WebSocket) {\n      this._emitError(new Error(\"tus: your browser doesn't supports WebSocket\"));\n      return;\n    }\n\n    if (!this.options.wsendpoint) {\n      this._emitError(new Error(\"tus: no wsendpoint provided\"));\n      return;\n    }\n\n    let file = this.file;\n\n    if (!file) {\n      this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n      return;\n    }\n\n    let source = this._source = getSource(file, this.options.chunkSize);\n\n    // Firstly, check if the caller has supplied a manual upload size or else\n    // we will use the calculated size by the source object.\n    if (this.options.uploadSize != null) {\n      let size = +this.options.uploadSize;\n      if (isNaN(size)) {\n        throw new Error(\"tus: cannot convert `uploadSize` option into a number\");\n      }\n\n      this._size = size;\n    } else {\n      let size = source.size;\n\n      // The size property will be null if we cannot calculate the file's size,\n      // for example if you handle a stream.\n      if (size == null) {\n        throw new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\");\n      }\n\n      this._size = size;\n    }\n\n    // Reset the aborted flag when the upload is started or else the\n    // _startUpload will stop before sending a request if the upload has been\n    // aborted previously.\n    this._aborted = false;\n\n    // The upload had been started previously and we should reuse this URL.\n    if (this.url != null) {\n      this._resumeUpload();\n      return;\n    }\n\n    // A URL has manually been specified, so we try to resume\n    if (this.options.uploadUrl != null) {\n      this.url = this.options.uploadUrl;\n      this._resumeUpload();\n      return;\n    }\n\n    // Try to find the endpoint for the file in the storage\n    if (this.options.resume) {\n      this._fingerprint = this.options.fingerprint(file);\n      let resumedUrl = Storage.getItem(this._fingerprint);\n\n      if (resumedUrl != null) {\n          this.url = resumedUrl;\n          this._resumeUpload();\n          return;\n      }\n    }\n\n    // An upload has not started for the file yet, so we start a new one\n    this._createUpload();\n  }\n\n  _setRequestHeaders() {\n    let headers = {\n      \"Tus-Resumable\": \"1.0.0\"\n    };\n\n    let optionsHeaders = this.options.headers;\n\n    for (let name in optionsHeaders) {\n      headers[name] = optionsHeaders[name];\n    }\n\n    return headers;\n  }\n\n  /**\n   * Create a new upload using the creation extension by sending a POST\n   * request to the endpoint. After successful creation the file will be\n   * uploaded\n   *\n   * @api private\n   */\n  _createUpload() {\n    let ws = this._newWebSocket();\n\n    ws.onopen = (event) => {\n      console.log(\"[Create] WS opened: \", event);\n\n      let headers = this._setRequestHeaders();\n      headers[\"Upload-Length\"] = this._size;\n\n      var metadata = encodeMetadata(this.options.metadata);\n      if (metadata !== \"\") {\n        headers[\"Upload-Metadata\"] = metadata;\n      }\n\n      ws.send(JSON.stringify({\n        method: \"POST\",\n        headers: headers,\n        body: null\n      }));\n    };\n\n    ws.onerror = (event) => {\n      console.log(\"[Create] WS error: \", event);\n      throw new Error(\"tus: failed to create upload\");\n    };\n\n    ws.onclose = (event) => {\n      console.log(\"[Create] WS closed: \", event);\n      throw new Error(\"tus: failed to create upload\");\n    };\n\n    ws.onmessage = (message) => {\n      let response = JSON.parse(message.data);\n\n      // Start upload\n      console.log(\"[Create] WS message: \", message);\n      console.log(\"[Create] WS data: \", response);\n\n      if (!inStatusCategory(response.status, 200)) {\n        // Must _emitXhrError\n        this._emitError(new Error(\"tus: unexpected response while creating upload\"));\n        return;\n      }\n\n      // this.url = resolveUrl(this.options.wsendpoint, response.headers[\"Location\"]);\n      this.url = response.headers[\"Location\"];\n\n      if (this.options.resume) {\n        Storage.setItem(this._fingerprint, this.url);\n      }\n\n      this._offset = 0;\n      this._startUpload();\n    };\n  }\n\n  _newWebSocket(){\n    return new WebSocket(\"ws://\"+this.options.wsendpoint+\"/ws\");\n  }\n\n  abort() {\n    if (this._xhr !== null) {\n      this._xhr.abort();\n      this._source.close();\n      this._aborted = true;\n    }\n\n    if (this._retryTimeout != null) {\n      clearTimeout(this._retryTimeout);\n      this._retryTimeout = null;\n    }\n  }\n\n  _emitXhrError(xhr, err, causingErr) {\n    this._emitError(new DetailedError(err, causingErr, xhr));\n  }\n\n  _emitError(err) {\n    if (typeof this.options.onError === \"function\") {\n      this.options.onError(err);\n    } else {\n      throw err;\n    }\n  }\n\n  _emitSuccess() {\n    if (typeof this.options.onSuccess === \"function\") {\n      this.options.onSuccess();\n    }\n  }\n\n  /**\n   * Publishes notification when data has been sent to the server. This\n   * data may not have been accepted by the server yet.\n   * @param  {number} bytesSent  Number of bytes sent to the server.\n   * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n   */\n  _emitProgress(bytesSent, bytesTotal) {\n    if (typeof this.options.onProgress === \"function\") {\n      this.options.onProgress(bytesSent, bytesTotal);\n    }\n  }\n\n  /**\n   * Publishes notification when a chunk of data has been sent to the server\n   * and accepted by the server.\n   * @param  {number} chunkSize  Size of the chunk that was accepted by the\n   *                             server.\n   * @param  {number} bytesAccepted Total number of bytes that have been\n   *                                accepted by the server.\n   * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n   */\n  _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n    if (typeof this.options.onChunkComplete === \"function\") {\n      this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n    }\n  }\n\n  /*\n   * Try to resume an existing upload. First a HEAD request will be sent\n   * to retrieve the offset. If the request fails a new upload will be\n   * created. In the case of a successful response the file will be uploaded.\n   *\n   * @api private\n   */\n  _resumeUpload() {\n    let ws = this._newWebSocket();\n\n    ws.onopen = (event) => {\n      console.log(\"[Resume] WS opened: \", event);\n\n      ws.send({\n        method: \"HEAD\",\n        headers: this._setRequestHeaders(),\n        body: null\n      });\n    };\n\n    ws.onerror = (event) => {\n      console.log(\"[Resume] WS error: \", event);\n      // Must _emitXhrError\n      this._emitError(new Error(\"tus: failed to resume upload\"));\n    };\n\n    ws.onclose = (event) => {\n      console.log(\"[Resume] WS closed: \", event);\n      // Must _emitXhrError\n      this._emitError(new Error(\"tus: failed to resume upload\"));\n    };\n\n    ws.onmessage = (message) => {\n      let response = JSON.parse(message.data);\n      let headers = response.headers;\n      \n      // Resume upload\n      console.log(\"[Resume] WS message: \", message);\n      console.log(\"[Resume] WS data: \", response);\n\n      if (!inStatusCategory(response.status, 200)) {\n        if (this.options.resume && inStatusCategory(response.status, 400)) {\n          // Remove stored fingerprint and corresponding endpoint,\n          // on client errors since the file can not be found\n          Storage.removeItem(this._fingerprint);\n        }\n\n        // !!!!!!!! ПРОТЕСТИТЬ !!!!!!!!\n        // If the upload is locked (indicated by the 423 Locked status code), we\n        // emit an error instead of directly starting a new upload. This way the\n        // retry logic can catch the error and will retry the upload. An upload\n        // is usually locked for a short period of time and will be available\n        // afterwards.\n        if (response.status === 423) {\n          // Must _emitXhrError\n          this._emitError(new Error(\"tus: upload is currently locked; retry later\"));\n          return;\n        }\n\n        // Try to create a new upload\n        this.url = null;\n        this._createUpload();\n        return;\n      }\n\n      let offset = parseInt(headers[\"Upload-Offset\"], 10);\n      if (isNaN(offset)) {\n        // MUST _emitXhrError\n        this._emitError(new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      let length = parseInt(headers[\"Upload-Length\"], 10);\n      if (isNaN(length)) {\n        // MUST _emitXhrError\n        this._emitError(new Error(\"tus: invalid or missing length value\"));\n        return;\n      }\n\n      // Upload has already been completed and we do not need to send additional\n      // data to the server\n      if (offset === length) {\n        this._emitProgress(length, length);\n        this._emitSuccess();\n        return;\n      }\n\n      this._offset = offset;\n      this._startUpload();\n    };\n  }\n\n  /**\n   * Start uploading the file using PATCH requests. The file will be divided\n   * into chunks as specified in the chunkSize option. During the upload\n   * the onProgress event handler may be invoked multiple times.\n   *\n   * @api private\n   */\n  _startUpload() {\n    // If the upload has been aborted, we will not send the next PATCH request.\n    // This is important if the abort method was called during a callback, such\n    // as onChunkComplete or onProgress.\n    if (this._aborted) {\n      return;\n    }\n\n    let ws = this._newWebSocket();\n\n    ws.onopen = (event) => {\n      console.log(\"[Start] WS opened: \", event);\n\n      // Test support for progress events before attaching an event listener\n      // if (\"upload\" in xhr) {\n      //   xhr.upload.onprogress = (e) => {\n      //     if (!e.lengthComputable) {\n      //       return;\n      //     }\n\n      //     this._emitProgress(start + e.loaded, this._size);\n      //   };\n      // }\n\n      let headers = this._setRequestHeaders();\n      headers[\"Upload-Offset\"] = this._offset;\n      headers[\"Content-Type\"] = \"application/offset+octet-stream\";\n  \n      let start = this._offset;\n      let end = this._offset + this.options.chunkSize;\n  \n      // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n      if (end === Infinity || end > this._size) {\n        end = this._size;\n      }\n\n      ws.send({\n        method: \"PATCH\",\n        headers: headers,\n        body: this._source.slice(start, end)\n      });\n    };\n\n    ws.onerror = (event) => {\n      console.log(\"[Start] WS error: \", event);\n\n      if (this._aborted) {\n        return;\n      }\n\n      // Must _emitXhrError\n      this._emitError(new Error(\"tus: failed to upload chunk at offset \" + this._offset));\n    };\n\n    ws.onclose = (event) => {\n      console.log(\"[Start] WS close: \", event);\n      \n      if (this._aborted) {\n        return;\n      }\n\n      // Must _emitXhrError\n      this._emitError(new Error(\"tus: failed to upload chunk at offset \" + this._offset));\n    };\n\n    ws.onmessage = (message) => {\n      let response = JSON.parse(message.data);\n      let headers = response.headers;\n      \n      // Resume upload\n      console.log(\"[Start] WS message: \", message);\n      console.log(\"[Start] WS data: \", response);\n\n      if (!inStatusCategory(response.status, 200)) {\n        // Must _emitXhrError\n        this._emitError(new Error(\"tus: unexpected response while uploading chunk\"));\n        return;\n      }\n\n      let offset = parseInt(headers[\"Upload-Offset\"], 10);\n      if (isNaN(offset)) {\n        // Must _emitXhrError\n        this._emitError(new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        // Yay, finally done :)\n        this._emitSuccess();\n        this._source.close();\n        return;\n      }\n\n      this._startUpload();\n    };\n  }\n}\n\nfunction encodeMetadata(metadata) {\n    if (!Base64.isSupported) {\n        return \"\";\n    }\n\n    var encoded = [];\n\n    for (var key in metadata) {\n        encoded.push(key + \" \" + Base64.encode(metadata[key]));\n    }\n\n    return encoded.join(\",\");\n}\n\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\nfunction inStatusCategory(status, category) {\n  return (status >= category && status < (category + 100));\n}\n\nUpload.defaultOptions = defaultOptions;\n\nexport default Upload;\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n"]}